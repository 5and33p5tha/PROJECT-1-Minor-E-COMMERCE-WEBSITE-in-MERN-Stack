const OrderItem = require("../Model/orderitems");
const Order = require("../Model/order");
const order = require("../Model/order");

//Say we have 3 products, product1, product2 and product3
//Now, initially all product will have their own ORDER ITEMS Table via Pre-Defined Procedure to be Followed
//After OrderItem Procedure, they will be passed in Order Table Function

//INITIALLY, SAY WE HAVE THREE PRODUCTS
//PRODUCT 1 (WHICH HAS ITEM ID I.E PRODUCT ID SAY = 1, AND QUANTITY SAY = 10)
//PRODUCT 2 (WHICH HAS ITEM ID I.E PRODUCT ID SAY = 2, AND QUANTITY SAY = 20)
//PRODUCT 3 (WHICH HAS ITEM ID I.E PRODUCT ID SAY = 3, AND QUANTITY SAY = 30)

//NOW IT WILL BE PUT IN MONGODB IN ORDER ITEM TABLE AS
//_ID(AUTO GENERATED BY MONGODB)                   QUANTITY            PRODUCT_ID I,E ID OF THAT CHOOSEN PRODUCT
//     1                                                 10                      A
//     2                                                 20                      B
//     3                                                 30                      C

//NOW THE PROMISE FUNCTION HAS TO BE USED AS UNLESS THESE THREE FUNCTIONS ARE INSERTED IN ORDERITEM TABLE, IT HAS TO HOLD OTHER FUNCTIONS THAT ARE SET AFTER THIS
//THIS IS THE WORKING OF PLACEORDER FUNCTION

//THIS WILL NOW GIVE ARRAY {1,2,3} WHERE 1,2,3 ARE THE MONGO GENERATED ID AND THAT ID WILL BE IN ORDER.JS
//HENCE IN ORDER, WHEN WE CALL THOSE ID, IT WILL SHOW THOSE TABLE VALUE AS ABOVE

//FUNCTION:-
exports.placeOrder = async (req, res) => {
  //only OrderItem is inn array as DEFINED IN ORDERITEM.JS
  //WE HAVE TO SET ALL THE FUNCTIONS FOR FIELDS IN ORDER.JS HERE
  const orderItemIds = await Promise.all(
    //Promise Function AS only after the following work is completed, NEXT WORK WILL BE ALLOWED.
    //I.E IF THREE PRODUCTS, IT WILL BE INSERTED IN ORDERITEMS TABLE AND UNTILL ALL THREE IS INSERTED, HOLD THE OTHER FUNCTIONS AFTER THIS
    //IT WILLL PRIORITIZE THE FOLLOWING FUNCTION AND WAIT UNTILL IT IS OVER
    req.body.orderItems.map(async (orderItem) => {
      //orderItems will come from customer SHOULD BE MAPPED THAT CREATES AN ARRAY AS SET IN ORDERITEM.JS
      let newOrderItem = new OrderItem({
        product: orderItem.product,
        quantity: orderItem.quantity,
      });
      newOrderItem = await newOrderItem.save();
      return newOrderItem._id;
    })
  );

  //Calculating Total Price

  //INDIVIDUAL TOTAL PRICE
  const individualTotalPrice = await Promise.all(
    //THIS AWAIT IS TO HOLD THIS ENTIRE FUNCTION
    //I.E UNTILL TOTAL PRICE 1, TOTAL PRICE 2 AND TOTAL PRICE 3 IS CALCULATED SAY FOR ABOVE EXAMPLE, THE REST OF THE FUNCTIONS SHOULD BE HOLD
    orderItemIds.map(async (orderItem) => {
      const order = await OrderItem.findById(orderItem).populate(
        //FINDBYID TO SEE THE PRICE AND QUANTITY IN FROM ORDERITEM TABLE
        //populate means we need those values
        "product",
        "product_price"
        //IN ORDER ITEM TABLE, WE HAVE PRODUCT BUT PRODUCT LEADS TO PRODUCTS.JS
        //SO WE GET PRODUCT PRICE FROM ORDERITEM.JS
      );
      //INDIVIDUAL TOTAL
      const total = order.quantity * order.product.product_price;
      return total;
    })

    //SIMILARLY, THE INDIVIDUAL TOTAL WILL BE CALCULATED FOR EACH PRODUCT LIKEWISE FOR ALL PRODUCT
  );

  /*
  arr = array and can be named a, b or anything
  acc = accumulator and can be named a, b  or anything
  arr = current index and can be named a, b or anything

arr = [1,2,3,4,5]
arr.reduce((acc,curr)=>{return acc+curr})
CURLY BRACKET USED SO RETURN SYNTAX IS NEEDED


  WORKING OF REDUX FUNCTION
acc = 1, curr = 2
acc = 1+2, curr = 3
acc = 3+3, curr = 4
acc = 6+4, curr = 5
acc = 10+5 
return 15
*/

  //FOR TOTAL PRICE
  const TotalPrice = individualTotalPrice.reduce((a, b) => a + b);
  // reduce function
  //AS CURLY BRACES IS NOT USED, NO NEED TO WRITE RETURN SYNTAX AS IT IS RETURNED AUTOMATICALLY
  //CURLY BRACKETS SYMBOLIZES MULTIPLE LINE STATEMENTS SO RETURN IS NECESSARY

  //NOW FOR ALL ORDER INFORMATIONS
  let order = new Order({
    OrderItems: orderItemIds, //Comes from above function
    user: req.body.user, //user comes from body  as set by user

    shippingAddress: req.body.shippingAddress, //shipping address 1comes from body  as given by user in form or any area set
    shippingAddress2: req.body.shippingAddress2, //shipping address 2 comes from body as entered by user
    phone: req.body.phone, //phone comes from body  as entered by user
    //STATUS NOT NEEDED AS BY DEFAULT IT IS PENDING UNTILL ANY CHANGES IS MADE
    totalPrice: TotalPrice, // comes from above function
  });

  //TO SAVE ORDER
  order = await order.save();
  if (!order) {
    //I.E NO ORDER FOUND
    return res.status(400).json({ error: "order could not be placed" });
  }
  res.send(order); //Return Saved Order
};

// TO VIEW ALL ORDER LIST
exports.orderList = async (req, res) => {
  const order = await Order.find().populate("user", "name");
  //COMMENTED FOR BELOW
  //POPULATE IS LIKE JOIN IN SQL
  //IF POPULATE IS NOT USED, IT WILL ONLY SHOW ID IN USER
  //USING POPULATE, IT SHOWS NAME AND ID
  //FOR MORE, CHECK IN POSTMAN

  //CAN BE COMMENTED FOR BELOW BUT BETTER TO CHANGE IT IN TWO STAGES I.E ORDER LIST AND ORDER DETAILS
  // const order = await Order.find().populate({path:'OrderItems',populate:{path:'product',populate:'category'}})

  if (!order) {
    return res.status(400).json({ error: "something went wrong" });
  }
  res.send(order);
};

//TO VIEW ORDER DETAIL OF PARTICULAR ONE ORDER
exports.orderDetail = async (req, res) => {
  const order = await Order.findById(req.params.orderid) //Here, id in req.params.id is Order ID
    .populate("user", "name") //FINDELEMENTSBY ORDER_ID
    .populate({
      path: "OrderItems",
      populate: { path: "product", populate: "category" },
    });
  //Incase of multiple models, we can do .populate("model1").populate("model2") aswell BUT its BETTER TO DO:-   populate: { path: "product", populate: "category" },
  //WHERE IN   populate: { path: "product", populate: "category" }, PRODUCT IS MODEL1 WHICH IS UNDER I.E BELONGS TO  CATEGORY WHICH IS MODEL 2
  //WORKING OF ABOVE LINE
  //here, populate (user, name) and
  //populate (OrderItems of Order, In OrderItems, We Have Product ID that links to product; SO POPULATE PRODUCT )
  // PRODUCT HAS CATEGORY I.E WHICH CATEGORY IT BELONGS IN, ALSO POPULATE CATEGORY
  //INDEED CATEGORY CONTAINS PRODUCT BUT WHAT WE STORE IS PRODUCT AND NOT CATEGORY. SO DONE AS ABOVE
  //simply put, HERE WE HAVE TO SHOW ENTIRE DETAILS, HENCE WE HAVE PERFORMED POPULATE
  //THIS HAS BEEN DONE FOR EACH INDIVIDUAL PRODUCTS THAT IS ORDERED i.e WE HAVE USED PATH AND POPULATE TO SHOW THE INTERCONNECTION BETWEEN ID THAT WE HAD SET.
  if (!order) {
    return res.status(400).json({ error: "something went wrong" });
  }
  res.send(order);
};

//To VIEW ORDER DETAILS of a particular user
exports.userOrder = async (req, res) => {
  const order = await Order.find({ user: req.params.userid })
    //find means find all
    //find one means GIVES JUSST ONE DATA
    //A user can have a lot of order HENCE WE USED FIND

    //find({user:req.params.userid}) MEANS FIND OF USER I.E SHOW ORDER HISTORY OF THAT USER (USER MAY HAVE ORDERED ONE ITEM IN DAY 1, 5 ITEMS IN DAY 10 ETC)

    //NOTE, WE CAN ALSO DO AS ABOVE LIKE findById(req.params.userid) BUT THIS IS ALOT BETTER

    // .populate("user", "name") //FINDELEMENTSBY ORDER_ID
    //SINCE THE DETAILS IS OF A PARTICULAR USER, NO NEED TO SHOW THEIR OWN NAME
    .populate({
      path: "OrderItems",
      populate: { path: "product", populate: "category" },
    });
  //WORKING OF ABOVE LINE
  //here, populate (user, name) and
  //populate (OrderItems of Order, In OrderItems, We Have Product ID that links to product; SO POPULATE PRODUCT )
  // PRODUCT HAS CATEGORY I.E WHICH CATEGORY IT BELONGS IN, ALSO POPULATE CATEGORY
  //INDEED CATEGORY CONTAINS PRODUCT BUT WHAT WE STORE IS PRODUCT AND NOT CATEGORY. SO DONE AS ABOVE
  //simply put, HERE WE HAVE TO SHOW ENTIRE DETAILS, HENCE WE HAVE PERFORMED POPULATE
  //THIS HAS BEEN DONE FOR EACH INDIVIDUAL PRODUCTS THAT IS ORDERED i.e WE HAVE USED PATH AND POPULATE TO SHOW THE INTERCONNECTION BETWEEN ID THAT WE HAD SET.
  if (!order) {
    return res.status(400).json({ error: "something went wrong" });
  }
  res.send(order);
};

//TO UPDATE ORDER
exports.updateOrder = async (req, res) => {
  const order = await Order.findByIdAndUpdate(
    req.params.orderid,
    {
      status: req.body.status,
      //TAKE FROM ORDER AND KEEP IN STATUS
      //BY DEFAULT, THE STATUS OF ORDER IS PENDING. I.E IN CHECKOUT, STATUS IS PENDING
      // THIS WILL TAKE THE STATUS IN ORDER AND KEEP HERE
      //status like DELIVERED, ON THE WAY, PENDING, CANCELLED ETC. THIS IS USED IN TRACKING
      //status is in backend
    },

    { new: true } //THIS WILL DISPLAY UPDATED VALUE AFTER SUCCESSFULL UPDATE
    //else, even after successful update, it will not be shown
  );

  if (!order) {
    return res.status(400).json({ error: "something went wrong" });
  }

  res.send(order);
};

//TO DELETE ORDER
exports.deleteOrder = (req, res) => {
  //can also write findByIdAndDelete instead Of findByIdAndRemove
  Order.findByIdAndRemove(req.params.orderid) //This IS To Delete Order,    //req.params.orderid = THE ORDER ID THAT IS IN URL
    //BUT BEFORE DELETING ORDER, IT NEEDS TO DELETE THE ITEMS INSIDE ORDER I.E ORDER ITEMS
    //SO TO DELETE ORDER ITEMS
    .then(async (deleteorder) => {
      //ASYNC ORDER I.E HOLD ORDER TO AWAIT ORDERITEMS I.E ORDER ITEMS
      if (deleteorder) {
        await deleteorder.OrderItems.map(async (deleteorderitems) => {
          //OrderItems = Model
          await OrderItems.findByIdAndRemove(deleteorderitem); //OrderItems = Model

          //THE ABOVE CODE WILL DELETE THE ORDER ITEMS FOR EACH ARRAY IN ORDER

          //ORDER:-
          // A- 1, 2, 3 WHERE 1, 2, 3 ARE ORDER ITEMS IN ARRAY

          //ALSO DELETION OF ORDER ITEMS WORKS AS:-

          //REMOVE 1 INITIALLY, THEN REMOVE 2 AND THEN 3
        });
        //IF SUCCESSFUL DELETION, DISPLAY
        return res.status(200).json({ msg: "Order Deleted Successfully" });
      } else {
        //IF ID IS FOUND BUT FAILED TO DELETE THE ORDER
        return res.status(400).json({ error: "Failed to delete order" });
      }
    })
    //CATCH ERROR OCCURS IF THERE IS ERROR IN READING I.E SAY NO SUCH ORDER FOUND TO DELETE OR INTERNAL ISSUES
    .catch((err) => {
      return res.status(400).json({ error: err }); //pass the err AS error in catch and SHOW IN 400
    });
};
